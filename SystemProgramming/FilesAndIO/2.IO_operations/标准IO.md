# 标准IO

主要分为C和C++两个部分，关于代码示例请查看当前目录下的其他文件示例。

[TOC]


## C语言中的标准IO

printf、scanf、fopen、fclose、fwrite、fread 是 C 语言中的标准 I/O 函数，它们用于文件的打开、关闭、写入和读取。它们的底层实现原理涉及操作系统提供的系统调用，负责处理文件操作，缓冲区管理，和错误处理。


### C标准IO的底层实现原理(重点)

> scanf 与 printf 的原理同下面的文件IO一致，重点为`缓冲区`。

- `fopen` (文件打开)
	fopen 通过调用底层的 open 系统调用，打开一个文件并返回文件指针（FILE *）。它不仅仅是直接打开文件，还设置了一个内存缓冲区，供文件操作时临时存储数据。
	缓冲区的引入提高了 I/O 操作的效率，减少了系统调用的次数。每次对文件的读写，不是立即发生，而是先在缓冲区中操作，等缓冲区满了或显式调用 fflush 时，才会真正执行系统调用。

- `fwrite` (文件写入)
	fwrite 将数据写入文件，但通常并不直接写入文件系统，而是先写入 fopen 分配的缓冲区。当缓冲区满时，或者调用 fflush 函数时，数据才会从缓冲区真正写入文件系统（这个通常也叫写缓冲）。
	写操作是通过 write 系统调用实现的。对于性能要求较高的场景，直接使用 write 可以跳过缓冲区管理。

- `fread` (文件读取)
	fread 从文件中读取数据，首先会尝试从缓冲区中读取。如果缓冲区没有足够的数据，fread 将调用底层的 read 系统调用，从文件中读取数据并填充缓冲区。
	缓冲区的存在减少了频繁的磁盘读操作，提升了 I/O 性能。

- `fclose` (文件关闭)
	fclose 用于关闭文件，通常会先将缓冲区中未写入的数据写入文件系统，再调用底层的 close 系统调用，释放文件描述符。
	关闭文件时，如果缓冲区有剩余数据而未写入，fclose 会尝试刷新缓冲区，确保所有数据都正确写入文件。

C和C++的标准I/O缓冲：两者的I/O都实现了缓冲机制，以提高性能。常见的缓冲类型有：

- 行缓冲：当遇到换行符时刷新缓冲区（stdout通常是行缓冲的）。

- 全缓冲：缓冲区满了才刷新，常见于文件输出。

- 无缓冲：立即输出，不经过缓冲区（例如stderr通常是无缓冲的）。


### C标准IO使用时的注意事项

1. 缓冲区管理

    标准 I/O 函数使用缓冲区来提高效率，但也带来了一些潜在问题。如果程序崩溃或者未正确关闭文件，缓冲区中的数据可能会丢失。
    在关键写入操作后，可以通过 fflush 手动刷新缓冲区，确保数据被及时写入文件。

2. 错误处理

    在使用这些函数时，必须检查返回值来判断操作是否成功。fopen 返回 NULL 表示文件打开失败，fwrite 和 fread 返回写入或读取的对象个数，必须与预期值匹配。错误时可以使用 perror 或 strerror 打印具体的错误信息。

3. 文件模式

    使用 fopen 时，文件模式参数非常重要。不同的模式（如 "r"、"w"、"a" 等）决定了文件的读写权限和行为。例如，"w" 模式会清空文件，"a" 模式则在文件末尾追加内容。
    在并发环境中，多个进程或线程访问同一文件时，文件模式要格外小心，避免数据竞态条件的发生。

4. 跨平台问题

    不同操作系统的文件系统和行为可能略有不同。标准 I/O 函数在不同平台上通常能够很好地兼容，但在进行文件路径、权限处理时，注意操作系统的差异性。

5. 并发访问

    在后端开发中，经常会有多个线程或进程对同一文件进行访问。在这种情况下，使用标准 I/O 函数时需要考虑并发问题，例如加锁、避免文件被多个进程同时写入而造成数据错误。
    对于频繁的并发文件操作，可能需要考虑使用无缓冲的 I/O 系统调用（如 open、read、write 等），或者使用文件锁（如 flock）。

6. 性能优化

    虽然标准 I/O 函数提供了缓冲区机制以提高性能，但在某些场景下，使用系统调用可能会更高效。例如，当需要进行大量小数据块的写入时，手动控制缓冲和系统调用可能会带来更好的性能。
    也可以考虑使用内存映射文件（如 mmap）来避免频繁的 I/O 操作，从而提升文件读写的性能。

## C++中的标准IO

C++ 的 iostream 是对 C 语言 stdio.h 的封装和扩展，使其更加面向对象、类型安全，并与 C++ 的其他特性（如模板、异常处理）更好地集成。

### C++标准IO的底层实现原理

C++ 的标准 I/O 底层实现建立在流（stream）的概念上，并在其背后使用了复杂的对象模型和缓冲机制。C++ 标准 I/O 是通过 `iostream` 库实现的，主要使用了面向对象设计、模板、以及一些与操作系统底层 I/O 系统的接口。理解其底层实现原理，有助于掌握其高效性、灵活性及一些常见问题的根源。

#### 1. **流（Stream）的概念**
C++ 中的标准 I/O 使用流来处理数据。流可以是输入流（`istream`）或输出流（`ostream`），它们是 I/O 操作的核心抽象。输入流代表数据从某个输入设备（如键盘、文件）流入程序，输出流则是数据从程序流向某个输出设备（如显示器、文件）。

- **`std::cin`**：标准输入流，对应输入设备，如键盘。
- **`std::cout`**：标准输出流，对应输出设备，如终端。
- **`std::cerr`**：标准错误流，用于输出错误消息。
- **`std::clog`**：用于记录非致命的日志信息。

#### 2. **类层次结构**
C++ 的标准 I/O 底层实现建立在类的层次结构上。核心类包括：

- **`ios_base`**：这是所有流类的基类，提供了流的基础设施，如状态标志（`fail`、`bad`、`eof`）等。
- **`basic_ios`**：派生自 `ios_base`，为具体的输入、输出流操作提供了接口，如 `get()`、`put()` 等方法。
- **`istream` / `ostream`**：分别用于输入流和输出流。它们继承了 `basic_ios`，并提供了额外的输入和输出操作。
- **`ifstream` / `ofstream`**：这些类是文件流，用于文件的读写操作，继承自 `istream` 和 `ostream`。

#### 3. **缓冲机制（重点）**
C++ 标准 I/O 使用了**缓冲区（buffer）**机制来提高 I/O 操作的效率。流数据不会直接读写到设备，而是会先经过一个缓冲区，以减少实际的 I/O 操作次数，提升性能。缓冲区的行为和大小可以通过相关函数（如 `std::ios::sync_with_stdio(false)`）进行调整。

- **输入缓冲**：当从 `std::cin` 读取数据时，数据实际上会先存储在一个缓冲区中。程序从缓冲区中读取数据，而不是直接从设备中读取。这使得输入操作能够在一定程度上进行优化，避免每次都进行系统调用。
  
- **输出缓冲**：类似地，输出操作也是通过缓冲区进行的。数据会先写入缓冲区，只有当缓冲区满了或者手动刷新（例如调用 `std::flush` 或输出换行符 `\n`）时，数据才会真正写入到输出设备。

#### 4. **运算符重载**
C++ 标准 I/O 的核心特性之一是使用了运算符重载来实现流的输入和输出操作。`<<` 和 `>>` 操作符被重载用于流的输出和输入操作。

- **`<<`（输出运算符）**：它将右侧的对象转换为相应的格式，并将其输出到左侧的流对象中。
- **`>>`（输入运算符）**：它从流中提取数据并存储到右侧的对象中。

  例如：
  ```cpp
  std::cout << "Hello, World!" << std::endl;  // 使用 << 运算符输出字符串
  int num;
  std::cin >> num;  // 使用 >> 运算符从输入流中读取整数
  ```

底层实现是通过**模板和运算符重载**实现的。运算符根据数据类型（如整数、浮点数、字符串等）进行相应的格式化处理。

#### 5. **缓冲同步（重点）**
C++ I/O 和 C I/O 在程序中可以共存。为了保持两者输出的一致性，C++ 默认会同步 `iostream` 和 C 标准库的 I/O 缓冲区（如 `stdout`）。这种同步保证了使用 `std::cout` 和 `printf()` 时输出的顺序一致性。

例如，以下代码中，`printf` 和 `std::cout` 会交替输出：
```cpp
#include <iostream>
#include <cstdio>

int main() {
    std::cout << "Hello from C++" << std::endl;
    printf("Hello from C\n");
    return 0;
}
```

但是，出于性能考虑，如果程序不需要使用 C I/O 函数（如 `printf`），可以通过 `std::ios::sync_with_stdio(false)` 关闭同步，以提高 I/O 性能。

#### 6. **异常处理**
C++ 标准 I/O 支持异常处理机制，当 I/O 操作失败时，可以通过流对象的异常状态标志进行处理。流类中提供了几个标志用于检测流的状态：
- **`fail()`**：如果 I/O 操作失败（如输入的格式不匹配），`failbit` 被设置，`fail()` 返回 `true`。
- **`eof()`**：如果读取到输入流的末尾，`eofbit` 被设置，`eof()` 返回 `true`。
- **`bad()`**：表示流发生严重错误，如 I/O 设备损坏，`badbit` 被设置，`bad()` 返回 `true`。

此外，C++ 允许使用 `exceptions()` 方法抛出异常，以捕获流的错误。

#### 7. **与操作系统的交互**
C++ 标准 I/O 的底层最终会调用操作系统的系统调用（如 `read()` 和 `write()`）来进行实际的 I/O 操作。流的缓冲区和状态管理在**应用层**进行，最终 I/O 请求通过 C 标准库或系统调用完成。

- **文件 I/O**：对于文件输入输出，C++ 使用 `ifstream` 和 `ofstream`，这些类封装了底层的文件操作系统调用。文件的打开、关闭、读写都是通过调用相应的文件描述符操作来实现的。

- **控制台 I/O**：控制台的输入输出也是通过调用操作系统提供的设备驱动进行的，标准输入输出设备在类 UNIX 系统上通常与文件描述符 `0`、`1`、`2` 关联。

#### 8. **本地化支持**
C++ I/O 系统提供了对不同语言环境的支持（locale），这意味着可以根据不同的地区和语言文化来改变 I/O 操作的行为。例如，输出时可以使用本地化的数字格式、日期格式等。

```cpp
std::cout.imbue(std::locale("de_DE")); // 使用德国的区域设置
std::cout << 1234.56 << std::endl;     // 输出: 1.234,56
```
